//Package Cache comment
// This file war generated by tars2go 1.1
// Generated from cache.tars
package Cache

import (
	"encoding/csv"
	"errors"
	"fmt"
	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
	"reflect"
	"strconv"
)

//DayKLine struct implement
type DayKLine struct {
	Date   string  `json:"date" csv:"date" array:"0"`
	Open   float64 `json:"open" csv:"open" array:"1"`
	High   float64 `json:"high" csv:"high" array:"2"`
	Low    float64 `json:"low" csv:"low" array:"3"`
	Close  float64 `json:"close" csv:"close" array:"4"`
	Volume int64   `json:"volume" csv:"volume" array:"5"`
}

func (st *DayKLine) resetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *DayKLine) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.resetDefault()

	err = _is.Read_string(&st.Date, 0, true)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Open, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.High, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Low, 3, true)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Close, 4, true)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Volume, 5, true)
	if err != nil {
		return err
	}

	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DayKLine) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.resetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DayKLine, but not exist. tag %d", tag)
		}
		return nil

	}

	st.ReadFrom(_is)

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

func (st *DayKLine) Update(_writer interface{}) error {

	if _w, ok := _writer.(*codec.Buffer); ok {
		return st.WriteTo(_w)
	}
	if _w, ok := _writer.(*csv.Writer); ok {
		return st.WriteCSV(_w)
	}
	return nil
}

//WriteTo encode struct to buffer
func (st *DayKLine) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Date, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Open, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.High, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Low, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Close, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Volume, 5)
	if err != nil {
		return err
	}

	return nil
}

//WriteBlock encode struct
func (st *DayKLine) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	st.WriteTo(_os)

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//写入
func (st *DayKLine) WriteCSV(_writer *csv.Writer) error {
	val := reflect.ValueOf(st)
	var line []string
	for i := 0; i < val.Elem().NumField(); i++ {
		fd := val.Elem().Field(i)
		vs := fmt.Sprintf("%v", fd)
		line = append(line, vs)
	}
	return _writer.Write(line)
}

//读取
func (st *DayKLine) ReadCsvRow(record []string) error {
	val := reflect.ValueOf(st).Elem()
	sts := val.NumField()
	rs := len(record)
	if sts > rs {
		sts = rs
	}
	for i := 0; i < sts; i++ {
		vf := val.Field(i)
		rv := record[i]
		var vs reflect.Value
		switch vf.Kind() {
		case reflect.Float64:
			if v, err := strconv.ParseFloat(rv, 64); err != nil {
				return errors.New(fmt.Sprintf("转换第%d字段为Float64失败:%v", i, err))
			} else {
				vs = reflect.ValueOf(v)
				break
			}
		case reflect.Float32:
			if v, err := strconv.ParseFloat(rv, 32); err != nil {
				return errors.New(fmt.Sprintf("转换第%d字段为Float32失败:%v", i, err))
			} else {
				vs = reflect.ValueOf(v)
				break
			}
		case reflect.Int32:
			if v, err := strconv.ParseInt(rv, 10, 32); err != nil {
				return errors.New(fmt.Sprintf("转换第%d字段为Int32失败:%v", i, err))
			} else {
				vs = reflect.ValueOf(int32(v))
				break
			}
		case reflect.Int64:
			if v, err := strconv.ParseInt(rv, 10, 64); err != nil {
				return errors.New(fmt.Sprintf("转换第%d字段为Int64失败:%v", i, err))
			} else {
				vs = reflect.ValueOf(v)
				break
			}
		case reflect.Bool:
			if v, err := strconv.ParseBool(rv); err != nil {
				return errors.New(fmt.Sprintf("转换第%d字段为Bool失败:%v", i, err))
			} else {
				vs = reflect.ValueOf(v)
				break
			}
		default:
			// reflect.String:
			vs = reflect.ValueOf(rv)
			break
		}
		vf.Set(vs)
	}
	return nil
}

//初始化
func (st *DayKLine) Init(_writer *csv.Writer) error {
	t := reflectType(st)
	fieldNum := t.NumField()
	var line []string
	for i := 0; i < fieldNum; i++ {
		f := t.Field(i)
		fn := f.Name
		line = append(line, fn)
	}
	return _writer.Write(line)
}

func reflectType(i any) reflect.Type {
	t := reflect.TypeOf(i)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	return t
}

func (st *DayKLine) ReadFromCsv(reader *csv.Reader) ([]DayKLine, error) {
	var result []DayKLine
	records, _ := reader.ReadAll()
	for row, record := range records {
		if row == 0 {
			continue
		}
		var kLine DayKLine
		err := kLine.ReadCsvRow(record)
		if err != nil {
			return nil, err
		}
		result = append(result, kLine)
	}
	return result, nil
}
